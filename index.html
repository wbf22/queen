<!DOCTYPE html>
<html lang="en" id="html" style="background-color: rgb(255, 255, 255); margin: 0px; padding: 0px; width: 100%;">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queen</title>
    <base target="_self">


    <style>
        #html {
            background-color: rgb(255, 255, 255);
            margin: 0px;
            padding: 0px;

            overflow-x: hidden;
        }

        #header {
            margin: 0px;
            background-color: rgb(224, 133, 215);
            padding: 1rem;
            display: flex;
            align-items: center;
        }

        #body {
            margin: 0px;
            padding: 0px;
            min-height: 100vh;
            font-family: Montserrat;
            color: rgb(224, 133, 215);

            overflow-x: hidden;
            overscroll-behavior-x: none;
        }

        #main_section {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: rgb(224, 133, 215);
            background-color: rgb(255, 255, 255);
        }

        #canvas_container {
            border-radius: 5px;
            border: 2px solid rgb(224, 133, 215);
            height: 40vh;
            width: 60vw;
            margin: 2rem 0rem 0rem;
        }

        #element_b53e0e1d5ebd48ae {
            width: 60vw;
            display: flex;
            flex-direction: column;
        }

        #element_858cce4c95524e10 {
            padding: 1rem;
        }

        #element_0849c3d19e254d31 {
            padding: 1rem;
        }

        #element_26cf65e584e24d92 {
            width: 60vw;
            margin: 2rem;
        }

        #element_f2868fccda224bd3 {
            display: flex;
            grid-template-columns: 1fr 4fr;
        }

        #element_265b987ceb254fe9 {
            padding: 1rem;
        }

        #temp_input {
            margin: 0px;
            padding: 0.5rem;
            place-self: center start;
            border: 2px solid rgb(224, 133, 215);
            border-radius: 5px;
        }

        #title {
            padding: 1rem;
            color: rgb(255, 255, 255);
        }

        #element_4693fc43131b4716 {
            padding: 1rem;
        }

        #element_c4ebd0ed321341be {
            padding: 1rem;
        }

        .date_select {
            padding: 1rem;
            margin: 1rem;
            border: 2px solid rgb(224, 133, 215);
            border-radius: 5px;
            width: 10rem;
            color: rgb(224, 133, 215);
        }

        #submit_event {
            padding: 0.5rem;
            background-color: rgb(224, 133, 215);
            width: 10rem;
            margin: 0rem 1rem;
            color: rgb(255, 255, 255);
            font-size: 1.2rem;
        }

        .pink_border {
            border: 2px solid rgb(224, 133, 215);
            border-radius: 5px;
            color: rgb(224, 133, 215);
            background-color: rgb(255, 255, 255);
        }

        #element_3d30a70ff1c4447d {
            display: flex;
            flex-direction: column;
        }

        #event_type_dropdown {
            padding: 1rem;
            background-color: rgb(255, 255, 255);
            border-radius: 5px;
            border: 2px solid rgb(224, 133, 215);
            color: rgb(224, 133, 215);
            margin: 0rem 1rem;
            width: 10rem;
        }

        .upload_download {
            padding: 0.2rem;
            background-color: rgb(224, 133, 215);
            width: 4rem;
            margin: 0rem 1rem;
            color: rgb(255, 255, 255);
            font-size: 0.7rem;
        }

        #graph_canvas {
            height: 40vh;
            width: 60vw;
        }

        #clear_events {
            background-color: rgb(255, 255, 255);
            padding: 0.2rem;
            width: 4rem;
            margin: 0rem 1rem;
            font-size: 0.7rem;
        }

        #element_a6eb3033d01144ad {
            padding: 1rem;
        }

        #element_7e8168c4524f4645 {
            margin: 1rem 0rem;
        }

        #element_e677238f138543b7 {
            padding: 0.5rem;
            background-color: rgb(224, 133, 215);
            width: 10rem;
            margin: 0rem 1rem;
            color: rgb(255, 255, 255);
            font-size: 1.2rem;
        }

        #element_f6680eb128e546c5 {
            display: flex;
            grid-template-columns: 1fr 4fr;
        }

        #element_cfd65f4507ba4e9e {
            padding: 0rem;
            display: flex;
            justify-content: end;
            margin: 0rem;
            width: 50%;
        }







        #element_efaf3ab7083e4edb {
            padding: 1rem;
            display: flex;
            justify-content: start;
        }

        #element_2de4c3a381154501 {
            padding: 0rem;
            width: 50%;
            margin: 0px;
        }

        #date_label {
            padding: 0rem;
            margin: 0px;
        }

        @media (max-width: 1024px) {
            #element_26cf65e584e24d92 {
                width: 90vw;
            }

            #canvas_container {
                width: 90vw;
            }

            #graph_canvas {
                width: 90vw;
            }

            #element_b53e0e1d5ebd48ae {
                width: 90vw;
            }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com" id="preconnect1">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" id="preconnect2">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&amp;display=swap"
        id="Montserrat">
</head>

<body id="body">

    <div id="header">
        <h1 id="title">Queen</h1>
        <svg width="3rem" height="3rem" viewBox="0 0 1024 1024" class="icon" version="1.1"
            xmlns="http://www.w3.org/2000/svg">
            <path
                d="M978.254 300.427c0-44.771-36.295-81.066-81.066-81.066s-81.066 36.295-81.066 81.066c0 36.02 23.501 66.537 56 77.097-21.517 17.157-59.595 32.926-126.933 33.356-98.134 0.626-159.304-91.429-189.636-154.361 33.482-9.969 57.904-40.97 57.904-77.689 0-44.771-36.295-81.066-81.066-81.066s-81.066 36.295-81.066 81.066c0 36.404 23.999 67.203 57.038 77.443-31.165 62.724-93.137 154.607-188.769 154.607-73.523 0-114.78-18.623-137.64-37.145 27.448-12.988 46.441-40.925 46.441-73.307 0-44.771-36.295-81.066-81.066-81.066s-81.066 36.295-81.066 81.066c0 39.38 28.086 72.191 65.316 79.524-12.668 28.179-25.648 67.273-24.783 107.941l162.132 238.131c18.844 141.239 88.656 162.132 263.464 162.132 157.675 0 263.709-21.647 283.73-162.132l141.865-238.131c3.577-41.747-13.475-83.128-30.004-112.471 29.496-12.127 50.271-41.129 50.271-74.995zM491.787 178.828c0-22.427 18.179-40.606 40.606-40.606 22.427 0 40.606 18.179 40.606 40.606 0 22.427-18.179 40.606-40.606 40.606-22.427 0-40.606-18.179-40.606-40.606zM106.724 300.427c0-22.427 18.179-40.606 40.606-40.606 22.427 0 40.606 18.179 40.606 40.606 0 22.427-18.179 40.606-40.606 40.606-22.427 0-40.606-18.179-40.606-40.606zM775.59 726.022c-18.779 120.741-102.206 121.349-243.197 121.599-156.909 0.278-202.91 7.105-222.931-121.599L145.488 488.854c-1.113-56.179 19.344-97.228 19.344-97.228s21.993 57.759 154.763 57.759S532.392 295.36 532.392 295.36s98.177 154.025 212.798 154.025 154.763-57.759 154.763-57.759 19.344 40.685 19.344 96.266L775.59 726.022z m121.598-384.989c-22.427 0-40.606-18.179-40.606-40.606 0-22.427 18.179-40.606 40.606-40.606 22.427 0 40.606 18.179 40.606 40.606 0 22.427-18.179 40.606-40.606 40.606z"
                fill="#ffffff"></path>
        </svg>
    </div>

    <div id="main_section">
        <div id="element_3d30a70ff1c4447d">
            <div id="canvas_container">
                <canvas id="graph_canvas" width="715" height="326"></canvas>
            </div>


            <div id="element_efaf3ab7083e4edb">
                <div id="element_2de4c3a381154501">
                    <p id="date_label">Nov 21</p>
                </div>
                <div id="element_cfd65f4507ba4e9e">
                    <button id="clear_events" class="pink_border"
                        onclick="clear_events()">Clear</button>
                    <button id="upload_button" class="upload_download pink_border">upload</button>
                    <button id="dowload_button" onclick="download_data()" class="upload_download pink_border">download</button>
                </div>
            </div>
        </div>
        <div id="element_b53e0e1d5ebd48ae">
            <h2 id="element_7e557ad4033c45e2">Log Event</h2>
            <select id="event_type_dropdown">
                <option id="element_858cce4c95524e10" value="very_heavy_bleeding">very heavy bleeding</option>
                <option id="element_0849c3d19e254d31" value="heavy_bleeding">heavy bleeding</option>
                <option id="element_0849c3d19e254d31" value="medium_bleeding">medium bleeding</option>
                <option id="element_0849c3d19e254d31" value="light_bleeding">light bleeding</option>
                <option id="element_c4ebd0ed321341be" value="spotting">spotting</option>
                <option id="element_4693fc43131b4716" value="positive_pregnancy_test">positive pregnancy test</option>
                <option id="element_4693fc43131b4716" value="faintly_positive_pregnancy_test">faintly positive pregnancy
                    test</option>
                <option id="element_4693fc43131b4716" value="negative_pregnancy_test">negative pregnancy test</option>
                <option id="element_4693fc43131b4716" value="fatigue">fatigue</option>
                <option id="element_4693fc43131b4716" value="tender_breasts">tender breasts</option>
                <option id="element_4693fc43131b4716" value="cramps">cramps</option>
                <option id="element_4693fc43131b4716" value="positive_ovulation_test">positive ovulation test</option>
                <option id="element_4693fc43131b4716" value="faintly_positive_ovulation_test">faintly positive ovulation
                    test</option>
                <option id="element_4693fc43131b4716" value="negative_ovulation_test">negative ovulation test</option>
                <option id="element_4693fc43131b4716" value="clearer_slippery_mucus">clear slippery mucus</option>
                <option id="element_4693fc43131b4716" value="sticky_or_thicker_mucus">sticky or thicker mucus</option>
                <option id="element_4693fc43131b4716" value="sick">sick</option>
                <option id="element_4693fc43131b4716" value="stress">stress</option>
            </select>
            <input id="event_date_select" class="date_select" type="date">
            <button id="submit_event" class="pink_border" onclick="submit_event()">Submit</button>

        </div>
        <div id="element_26cf65e584e24d92">
            <h2 id="element_fde29288b6384ae3">Log Basal Body Temperature</h2>
            <div id="element_f2868fccda224bd3">
                <p id="element_265b987ceb254fe9">Temp</p>
                <input id="temp_input" type="">



            </div>
            <div id="element_f6680eb128e546c5">


                <p id="element_a6eb3033d01144ad">Date</p>
                <input id="temp_date_select" class="date_select" type="date">

            </div>
            <button id="element_e677238f138543b7" class="pink_border" onclick="submit_temp()">Submit</button>
        </div>
    </div>




    <!-- util -->
    <script>
        function date_to_str(date) {
            const options = { month: 'numeric', day: 'numeric', year: 'numeric' };
            return new Intl.DateTimeFormat('en-US', options).format(date);
        }

        function time_less_date_from_calendar(input) {
            const [year, month, day] = input.value.split('-').map(Number);
            return new Date(year, month - 1, day);
        }

        function time_less_date_today() {
            const now = new Date();
            return new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
        }

        function add_to_list_map(map, key, value) {

            if (map.has(key)) {
                let current_list = map.get(key);
                current_list.push(value);
                map.set(
                    key,
                    current_list
                );
            }
            else {
                map.set(
                    key,
                    [value]
                );
            }
        }

        function days_between(first_date, last_date) {
            const msPerDay = 1000 * 60 * 60 * 24;
            const diff = new Date(last_date) - new Date(first_date);
            return Math.round(diff / msPerDay); // round to nearest day
        }

        function get_date_plus_days(date, num_days) {
            const newDate = new Date(date); // copy original date
            newDate.setDate(newDate.getDate() + num_days);
            return newDate;
        }

        function local_storage_save(key, obj) {

            if (obj instanceof Map) {
                localStorage.setItem(key, JSON.stringify(Array.from(obj.entries())));
            }
            else {
                localStorage.setItem(key, JSON.stringify(obj));
            }
        }

        function local_storage_get_map(key) {
            const stored = localStorage.getItem(key);
            if (!stored) return new Map();
            
            const obj = JSON.parse(stored);
            return new Map(obj);
        }

        function local_storage_get(key) {
            return JSON.parse(localStorage.getItem(key));
        }

        function future_favor_weighted_avg(list) {

            let total_weights = 0;
            let avg = 0;
            for (let i = 0; i < list.length; i++) {
                let weight = 1 + Math.sqrt(i);
                avg += list[i] * weight;
                total_weights += weight;
            }
            avg /= total_weights;
            return avg;
        }

    </script>


    <!-- general -->
    <script>

        let bb_temperatures = new Map();
        let events = new Map();
        let predictions = new Map();
        let avg_period_duration = 5;
        let avg_cycle_lenght = 28;
        let avg_ovulation_symptoms_to_period_start = 14;
        let avg_symptoms_to_period_start = 2;
        let is_pregnant = false;

        let priorities = new Map([
            ["negative_pregnancy_test", 11],
            ["positive_pregnancy_test", 10],
            ["faintly_positive_pregnancy_test", 10],
            ["positive_ovulation_test", 10],
            ["faintly_positive_ovulation_test", 10],
            ["negative_ovulation_test", 10],
            ["very_heavy_bleeding", 9],
            ["heavy_bleeding", 9],
            ["medium_bleeding", 9],
            ["light_bleeding", 9],
            ["spotting", 8],
            ["fatigue", 5],
            ["tender_breasts", 5],
            ["cramps", 5],
            ["clearer_slippery_mucus", 5],
            ["sticky_or_thicker_mucus", 5],
            ["sick", 5],
            ["stress", 5]
        ]);

        let START_DATE = get_date_plus_days(time_less_date_today(), -20);
        let SELECTED_DATE = null;

        let event_type_dropdown = document.getElementById("event_type_dropdown");
        let graph_canvas = document.getElementById("graph_canvas");
        const ctx = graph_canvas.getContext('2d');



        function submit_event() {

            // add to graph
            const date = time_less_date_from_calendar(document.getElementById("event_date_select"));
            const date_str = date_to_str(date);
            add_to_list_map(events, date_str, event_type_dropdown.value);
            make_predictions(events, bb_temperatures);
            draw_graph(START_DATE, bb_temperatures, events);

            // add to local storage
            local_storage_save("events", events);
        }

        function clear_events() {
            // remove from graph
            const date_str = date_to_str(SELECTED_DATE);
            events.delete(date_str);
            bb_temperatures.delete(date_str);
            make_predictions(events, bb_temperatures);
            draw_graph(START_DATE, bb_temperatures, events);


            // remove from local storage
            local_storage_save("events", events);
            local_storage_save("bb_temperatures", bb_temperatures);
        }

        function submit_temp() {

            const temp = parseFloat(document.getElementById("temp_input").value);

            if (temp > 104 || temp < 92) {
                alert("That temperature is strange: " + temp + " F\n\n(not celcius) If that's really your temperature you should see a doctor.")
                return;
            }


            const date = time_less_date_from_calendar(document.getElementById("temp_date_select"));


            // add to graph
            bb_temperatures.set(
                date_to_str(date),
                temp
            );
            make_predictions(events, bb_temperatures);
            draw_graph(START_DATE, bb_temperatures, events);

            // add to local storage
            local_storage_save("bb_temperatures", bb_temperatures);

        }

        function is_bleeding(event) {
            return event == "very_heavy_bleeding" || event == "heavy_bleeding" || event == "medium_bleeding" || event == "light_bleeding";
        }


        function mark_out_ovulation_days(event_days, today_date, ovulation_index, override_level) {


            // check for ovulation symptoms
            let last_temperatures = [];
            let start_j = ovulation_index - 10;
            let start_date = get_date_plus_days(today_date, start_j - event_days.length);
            if (override_level > -1) {
                for (let j = start_j; j < ovulation_index + 10; j++) {
                    if (j > 0) {
                        if (event_days[j] == "clearer_slippery_mucus" && override_level < 1) {
                            ovulation_index = j;
                        }
                        if (event_days[j] == "positive_ovulation_test" || event_days[j] == "faintly_positive_ovulation_test") {
                            if (override_level < 2) {
                                ovulation_index = j - 2;
                                override_level = 1;
                            }
                        }

                        // modify if not ovulating
                        if (
                            (event_days[j - 2] == "negative_ovulation_test" || event_days[j - 2] == "sticky_or_thicker_mucus") &&
                            ovulation_index == j - 2
                        ) {
                            ovulation_index++;
                        }
                    }


                    // look at bb temp
                    let curr_date = get_date_plus_days(today_date, j - event_days.length);
                    let temp = bb_temperatures.get(date_to_str(curr_date));
                    if (temp) {
                        last_temperatures.push([curr_date, temp]);

                        if (last_temperatures.length > 6) {
                            let ind = last_temperatures.length - 1;
                            if (days_between(curr_date, last_temperatures[ind - 1][0]) < 3) {
                                // get average for last 2 days
                                let recent_avg_temp = (temp + last_temperatures[ind - 1][1]) / 2;

                                // get average 3 days before that
                                let past_avg_temp = 0;
                                past_avg_temp += last_temperatures[ind - 3][1];
                                past_avg_temp += last_temperatures[ind - 4][1];
                                past_avg_temp += last_temperatures[ind - 5][1];
                                past_avg_temp /= 3;

                                // check if temp has risen
                                if (days_between(curr_date, last_temperatures[ind - 4][0]) < 8) {
                                    let diff = recent_avg_temp - past_avg_temp;
                                    if (diff > 0.4) {
                                        override_level = 4;
                                        ovulation_index = j - 2;
                                        console.log("bb temp ovulation detected " + date_to_str(curr_date));
                                    }
                                }

                            }

                        }

                    }
                }
            }
            

            // mark out days
            for (let o = ovulation_index - 5; o < ovulation_index; o++) {
                let ovulation_date = get_date_plus_days(today_date, o - event_days.length);
                predictions.set(date_to_str(ovulation_date), "ovulation");
                if (o == ovulation_index - 5) {
                    predictions.set(date_to_str(ovulation_date), "ovulation_start");
                }
            }
            let ovulation_date = get_date_plus_days(today_date, ovulation_index - event_days.length);
            predictions.set(date_to_str(ovulation_date), "ovulation_end");
        }

        function make_predictions(events, bb_temperatures) {

            /*
                return:
                - period predictions
                - ovulation predictions
                - pregnancy predictions


                period
                - look for bleeding
                - use averages of period to period
                - if fatigue, tender breats, or cramps; and near expected period, adjust using symptoms to period averages
                

                ovulation
                - look for time until next period, and use past averages or 12-16 days before period
                - rises in bb temperature over 3 days indicate ovulation has happened, adjust averages accordingly
                - also clear slippery mucus also indicates ovulation, adjust averages accordinly

                pregnancy
                - prompt to take pregnancy test if period is very overdue ( like 2 cycles over )
                - pregnant if positive pregnancy test
                - pregnant if faint positive pregnancy test and period is overdue
                - if pregnant:
                    - mark conception date
                    - mark expected due date, 280 days from first day of last period, or 266 days from ovulation date
                    - show baby size
                    - if positive pregnancy test with subsequent significant bleeding, cancel pregnancy if miscarriage and remove all these events
            */

            /*

                1. scan events for periods (2 consecutive bleeding days)
                    - also collect period symptoms to period start averages
                2. ovulation
                    - collect mucus symptoms or bb temp rises to next period start if within 10-18 days of next period
                    - use those averages to set ovulation x days before predicted periods
                3. pregnancy
                    - pregnant if positive pregnancy test, or faint positive test and period is overdue by at least one cycle
                    - mark conception date
                    - mark due date 266 days from ovulation date
                    - at week 15 show baby sizes (lower risk of miscarriage)
                    - if positive pregnancy test with subsequent significant bleeding, cancel pregnancy if miscarriage and remove all these events
            */

            predictions = new Map();
            let period_durations = [5];
            let cycle_lengths = [28];
            let ovulation_symptoms_to_period_start = [14];
            let symptoms_to_period_start = [2];

            // periods
            const events_list = Array.from(events.entries())
                .sort((a, b) => new Date(a[0]) - new Date(b[0])); // sort by date

            if (events_list.length > 0) {
                is_pregnant = false;
                let curr_date = time_less_date_today();

                // collect all events per day
                let history_length_days = days_between(new Date(events_list[0][0]), curr_date);
                if (history_length_days < 0) return;

                let event_days = new Array(history_length_days).fill(null);
                let first_date = new Date(events_list[0][0]);
                for (let date_and_events of events_list) {
                    let date_str = date_and_events[0];
                    let events = date_and_events[1];

                    for (let event of events) {
                        let curr_date = new Date(date_str);
                        let index = days_between(first_date, curr_date);
                        let curr_event = event_days[index];
                        if (!curr_event || priorities.get(event) > priorities.get(curr_event)) {
                            event_days[index] = event;
                        }
                    }

                }

                // determine period lengths and cycle lengths
                let last_period_start_index = null;
                let current_period_start_index = null;
                let positive_pregnancy_test = null;
                let consecutive_bleeding = 0;
                for (let i = 0; i < event_days.length; i++) {

                    let event = event_days[i];
                    if (event && is_bleeding(event)) {

                        if (event == "very_heavy_bleeding" || event == "heavy_bleeding" || event == "medium_bleeding") {
                            consecutive_bleeding++;
                            if (positive_pregnancy_test) positive_pregnancy_test = null; // detected miscarriage
                        }
                        else if (event == "light_bleeding" && consecutive_bleeding > 1) {
                            consecutive_bleeding++;
                        }

                        // period has started
                        if (consecutive_bleeding == 2) {
                            current_period_start_index = i - 1;
                            if (last_period_start_index) {
                                cycle_lengths.push(current_period_start_index - last_period_start_index);
                            }

                            // look back for symptoms
                            for (let j = i - 7; j < i; j++) {
                                if (j > 0 && (event_days[j] == "fatigue" || event_days[j] == "tender_breasts" || event_days[j] == "cramps")) {
                                    symptoms_to_period_start.push(i - j);
                                }
                            }

                        }
                    }
                    else {

                        // period has ended
                        if (consecutive_bleeding > 2) {
                            // look back for ovulation (and predict past ovulations)
                            ovulation_index = current_period_start_index - avg_ovulation_symptoms_to_period_start;
                            mark_out_ovulation_days(event_days, curr_date, ovulation_index, 3);

                            // reset for next period
                            period_durations.push(consecutive_bleeding);
                            last_period_start_index = current_period_start_index;
                            current_period_start_index = null;
                            consecutive_bleeding = 0;

                        }

                        if (event == "positive_pregnancy_test" || event == "faintly_positive_pregnancy_test") {
                            positive_pregnancy_test = [i, event];
                        }

                        if (event == "negative_pregnancy_test") {
                            positive_pregnancy_test = null;
                        }
                    }
                }

                if (!last_period_start_index) last_period_start_index = 0;

                // compute averages
                avg_period_duration = future_favor_weighted_avg(period_durations);
                avg_cycle_lenght = future_favor_weighted_avg(cycle_lengths);
                avg_ovulation_symptoms_to_period_start = future_favor_weighted_avg(ovulation_symptoms_to_period_start);
                avg_symptoms_to_period_start = future_favor_weighted_avg(symptoms_to_period_start);

                // MAKE PREDICTIONS (periods, ovulations, if pregnant: conception, due date, if pregnant 15 weeks: baby sizes)
                let last_period_date = get_date_plus_days(first_date, last_period_start_index);
                let days_since_last_period = event_days.length - last_period_start_index;
                let days_until_next_period = Math.max(avg_cycle_lenght - days_since_last_period, 0);


                // determine if pregnant
                if (positive_pregnancy_test) {
                    let index = positive_pregnancy_test[0];
                    let test_event = positive_pregnancy_test[1];

                    if (test_event == "positive_pregnancy_test") {
                        is_pregnant = true;
                    }
                    else if (test_event == "faintly_positive_pregnancy_test" && days_since_last_period > avg_cycle_lenght * 1.5) {
                        is_pregnant = true;
                    }
                }

                // if ovulation before next period
                if (days_until_next_period < avg_ovulation_symptoms_to_period_start) {
                    let days_until_ovulation = event_days.length + days_until_next_period - avg_ovulation_symptoms_to_period_start;
                    mark_out_ovulation_days(event_days, curr_date, days_until_ovulation, 0);
                }

                if (!is_pregnant) {


                    let cycles_overdue = (event_days.length - last_period_start_index) / avg_cycle_lenght;
                    if (cycles_overdue > 2 && local_storage_get("take_pregnancy_test_shown") != date_to_str(curr_date)) {
                        local_storage_save("take_pregnancy_test_shown", date_to_str(curr_date));
                        alert("Hey it looks like it's been a while since your last period. Might be good to take a pregnancy test if it's possible you're pregnant.");
                    }


                    // if recent symptoms and period soon
                    if (days_until_next_period < 7) {
                        for (let i = event_days.length - 1; i > event_days.length - 5; i--) {
                            if (event_days[i] == "fatigue" || event_days[i] == "tender_breasts" || event_days[i] == "cramps") {
                                days_until_next_period = (i - event_days.length) + avg_symptoms_to_period_start;
                                days_until_next_period = Math.max(days_until_next_period, 0);
                                break;
                            }
                        }
                    }

                    // if recent symptoms and ovulation soon (12-16 days before period)
                    if (days_until_next_period > 12 && days_until_next_period < 20) {
                        for (let i = event_days.length - 1; i > event_days.length - 5; i--) {
                            if (
                                event_days[i] == "positive_ovulation_test" ||
                                event_days[i] == "faintly_positive_ovulation_test" ||
                                event_days[i] == "clearer_slippery_mucus"
                            ) {
                                days_until_next_period = (i - event_days.length) + avg_ovulation_symptoms_to_period_start;
                                days_until_next_period = Math.max(days_until_next_period, 0);
                                break;
                            }
                        }
                    }

                    let next_period_date = get_date_plus_days(curr_date, days_until_next_period);

                    // predict out periods and ovulations for the next 10 cycles
                    for (let p = 0; p < 10; p++) {

                        // ovulation
                        let days_until_ovulation = days_until_next_period + p * avg_cycle_lenght - avg_ovulation_symptoms_to_period_start;
                        if (days_until_ovulation > 0) {
                            mark_out_ovulation_days(event_days, curr_date, days_until_ovulation + event_days.length, -1);
                        }

                        // period
                        let period_date = new Date(next_period_date);
                        period_date.setDate(period_date.getDate() + p * avg_cycle_lenght);
                        predictions.set(date_to_str(period_date), "period_start");
                        for (let i = 0; i < avg_period_duration; i++) {
                            period_date.setDate(period_date.getDate() + 1);
                            predictions.set(date_to_str(period_date), "period");
                        }
                        predictions.set(date_to_str(period_date), "period_end");

                    }
                }


                // pregnancy pridictions
                if (is_pregnant) {
                    /*

                        pregnancy
                        - prompt to take pregnancy test if period is very overdue ( like 2 cycles over )
                        - pregnant if positive pregnancy test
                        - pregnant if faint positive pregnancy test and period is overdue
                        - if pregnant:
                            - mark conception date
                            - mark expected due date, 280 days from first day of last period, or 266 days from ovulation date
                            - show baby size
                            - if positive pregnancy test with subsequent significant bleeding, cancel pregnancy if miscarriage and remove all these events
                    */

                    // mark conception date
                    let index = positive_pregnancy_test[0];
                    let test_event = positive_pregnancy_test[1];
                    while (index > 0) {
                        let search_date = get_date_plus_days(first_date, index);
                        if (predictions.has(date_to_str(search_date)) && predictions.get(date_to_str(search_date)).includes("ovulation")) {
                            break;
                        }
                        index--;
                    }


                    let conception_date = get_date_plus_days(first_date, index);
                    predictions.set(date_to_str(conception_date), "conception_date")


                    // mark expected due date
                    let due_date = get_date_plus_days(conception_date, 266);

                    const options = { month: 'short', year: 'numeric' };
                    const formatted = new Intl.DateTimeFormat('en-US', options).format(due_date);
                    predictions.set(date_to_str(due_date), formatted + " due date üéâ")

                    // baby sizes if over 6 weeks
                    let week6 = get_date_plus_days(conception_date, 6 * 7 - avg_ovulation_symptoms_to_period_start);
                    let week10 = get_date_plus_days(conception_date, 10 * 7 - avg_ovulation_symptoms_to_period_start);
                    let week15 = get_date_plus_days(conception_date, 15 * 7 - avg_ovulation_symptoms_to_period_start);
                    let week20 = get_date_plus_days(conception_date, 20 * 7 - avg_ovulation_symptoms_to_period_start);
                    let week25 = get_date_plus_days(conception_date, 25 * 7 - avg_ovulation_symptoms_to_period_start);
                    let week30 = get_date_plus_days(conception_date, 30 * 7 - avg_ovulation_symptoms_to_period_start);
                    let week35 = get_date_plus_days(conception_date, 35 * 7 - avg_ovulation_symptoms_to_period_start);
                    let week40 = get_date_plus_days(conception_date, 39 * 7 - avg_ovulation_symptoms_to_period_start);

                    predictions.set(date_to_str(week6), "baby is a üç¨");
                    predictions.set(date_to_str(week10), "baby is a üçì");
                    predictions.set(date_to_str(week15), "baby is a üçé");
                    predictions.set(date_to_str(week20), "baby is a üçå");
                    predictions.set(date_to_str(week25), "baby is a üçà");
                    predictions.set(date_to_str(week30), "baby is a üçÜ");
                    predictions.set(date_to_str(week35), "baby is a üçç");
                    predictions.set(date_to_str(week40), "baby is a üèÄ");



                }


            }

        }



    </script>


    <!-- graph -->
    <script>

        let FONT_SIZE = window.innerWidth <= 1024 ? 24 : 30;
        let GRAPH_DAY_WIDTH_PIXELS = window.innerWidth <= 1024 ? 12 : 22;
        window.addEventListener('resize', () => {
            FONT_SIZE = window.innerWidth <= 1024 ? 24 : 30;
            GRAPH_DAY_WIDTH_PIXELS = window.innerWidth <= 1024 ? 12 : 22;
            draw_graph(START_DATE, bb_temperatures, events);
        });
        
        let Y_MARGIN = 40;
        let Y_MARGIN_TOP = 80;
        let BB_MARGIN = 20;
        let text_positions = [0, 3, 8, 6, 2, 4, 7, 1, 5, 20, 15, 9, 11, 19, 12, 18, 14, 16, 12, 17, 13, 10, 15];
        let text_i = 0;
        function draw_flag(ctx, text, x, color, background_color, is_dashed) {

            // determine flag position
            let max_text_pos = (graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP) / FONT_SIZE;
            let text_pos = text_positions[text_i] < max_text_pos ? text_positions[text_i] : text_positions[text_i] % Math.floor(max_text_pos);
            let y_text = Y_MARGIN + FONT_SIZE * text_pos;


            // draw line
            ctx.beginPath();
            if (is_dashed) {
                ctx.setLineDash([5, 5]);
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.moveTo(x, y_text);
            ctx.lineTo(x, graph_canvas.height - Y_MARGIN_TOP);
            ctx.stroke();
            ctx.setLineDash([]);

            // draw text with background
            ctx.font = `${FONT_SIZE}px Arial`;
            const metrics = ctx.measureText(text);
            const textWidth = metrics.width + 8;
            const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
            ctx.fillStyle = background_color;
            ctx.fillRect(x - 1, y_text - metrics.actualBoundingBoxAscent - 4, textWidth + 4, textHeight + 4);
            ctx.fillStyle = color;
            ctx.fillText(text, x + 5, y_text);
            text_i = (text_i + 1) % text_positions.length;
        }

        function draw_graph(start_date, bb_temperatures, events) {


            // clear graph
            text_i = 0;
            const rect = graph_canvas.getBoundingClientRect();
            graph_canvas.width = rect.width * 2;
            graph_canvas.height = rect.height * 2;
            ctx.clearRect(0, 0, graph_canvas.width, graph_canvas.height);

            // determine x step
            const num_days = graph_canvas.width / GRAPH_DAY_WIDTH_PIXELS;
            end_date = get_date_plus_days(start_date, num_days);
            const step_x = GRAPH_DAY_WIDTH_PIXELS;
            SELECTED_DATE = get_date_plus_days(start_date, graph_canvas.width / 2 / step_x);

            // determine temp y step
            let min_temp = bb_temperatures.size == 0 ? 96 : bb_temperatures.values().next().value;
            let max_temp = bb_temperatures.size == 0 ? 100 : bb_temperatures.values().next().value;
            for (let temp of bb_temperatures.values()) {
                if (temp < min_temp) {
                    min_temp = temp;
                }
                if (temp > max_temp) {
                    max_temp = temp;
                }
            }
            max_temp = min_temp == max_temp ? min_temp + 2 : max_temp;
            max_temp += 0.5
            min_temp -= 0.5
            Y_MARGIN = graph_canvas.height * .2;
            Y_MARGIN_TOP = graph_canvas.height * .4;
            BB_MARGIN = graph_canvas.height * .1;
            const step_y = (Y_MARGIN_TOP - BB_MARGIN) / (max_temp - min_temp);

            // determine last temp
            let last_date = null;
            let last_temp = null;
            let last_temp_y = last_temp ? graph_canvas.height - Y_MARGIN - step_y * (last_temp - min_temp) : null;
            let last_temp_x = 0;

            // walk through dates drawing
            let curr_date = new Date(start_date);
            let i = 0;
            let temperatures = [];
            while (curr_date < end_date) {

                // draw gird lines
                let x = step_x * i;
                if (curr_date.getDate() == 1) {

                    const options = { month: 'short', year: 'numeric' };
                    const formatted = new Intl.DateTimeFormat('en-US', options).format(curr_date);
                    ctx.font = `${FONT_SIZE}px Arial`;
                    ctx.fillStyle = 'rgb(200, 200, 200)';
                    ctx.fillText(formatted, x + 5, graph_canvas.height - 20);
                }
                if (curr_date.getDate() == 1) {

                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, graph_canvas.height);
                    ctx.strokeStyle = 'rgb(200, 200, 200)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                }

                if (curr_date.getDate() == SELECTED_DATE.getDate() && curr_date.getMonth() == SELECTED_DATE.getMonth()) {
                    ctx.fillStyle = `rgba(102, 192, 222,0.5)`;
                    ctx.fillRect(x, Y_MARGIN / 2, 6, graph_canvas.height - Y_MARGIN);

                    // set date label
                    const options = { month: 'short', day: 'numeric' };
                    const formatted = new Intl.DateTimeFormat('en-US', options).format(curr_date);
                    document.getElementById("date_label").textContent = formatted;

                    // set date inputs
                    const date_str = SELECTED_DATE.toISOString().split('T')[0];
                    document.getElementById("event_date_select").value = date_str;
                    document.getElementById("temp_date_select").value = date_str;
                }


                // draw temperature for this day
                const date_str = date_to_str(curr_date);
                if (bb_temperatures.has(date_str)) {
                    let temp = bb_temperatures.get(date_str);
                    temperatures.push([new Date(curr_date), temp]);
                    let y = graph_canvas.height - BB_MARGIN - step_y * (temp - min_temp);
                    ctx.beginPath();
                    ctx.arc(x, y, 2.5, 0, Math.PI * 2); // full circle
                    ctx.fillStyle = 'rgb(224, 133, 215)'; // color of the dot
                    ctx.fill();

                    if (last_temp_y) {
                        ctx.beginPath();
                        ctx.moveTo(last_temp_x, last_temp_y);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = 'rgb(224, 133, 215)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    last_temp_x = x;
                    last_temp_y = y;
                }

                // draw events for this day
                if (events.has(date_str)) {

                    let events_on_date = events.get(date_str);
                    for (let type of events_on_date) {

                        if (type.includes("bleeding") || type.includes("spotting")) {

                            let strength = 0.5;
                            if (type == "very_heavy_bleeding") {
                                strength = 0.5;
                            }
                            else if (type == "heavy_bleeding") {
                                strength = 0.4;

                            }
                            else if (type == "medium_bleeding") {
                                strength = 0.3;

                            }
                            else if (type == "light_bleeding") {
                                strength = 0.2;

                            }
                            else if (type == "spotting") {
                                strength = 0.1;
                            }

                            ctx.fillStyle = `rgba(224, 133, 215,${strength})`;
                            ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);

                        }

                        if (type == "positive_pregnancy_test" || type == "faintly_positive_pregnancy_test") {
                            let text = curr_date.getDate() + (type == "positive_pregnancy_test" ? " positive pregnancy test üëë" : " faint pregnancy test");
                            let color = type == "positive_pregnancy_test" ? "rgba(219, 33, 117, 1.0)" : "rgba(219, 33, 117, 1.0)";
                            let background_color = type == "positive_pregnancy_test" ? "rgba(219, 33, 117, 0.3)" : "rgba(219, 33, 117, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "negative_pregnancy_test") {
                            let text = curr_date.getDate() + " negative pregnancy test";
                            let color = "rgba(110, 57, 0, 1.0)";
                            let background_color = "rgba(110, 57, 0, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "fatigue") {
                            let text = curr_date.getDate() + " fatigue";
                            let color = "rgba(162, 39, 219, 1.0)";
                            let background_color = "rgba(162, 39, 219, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "tender_breasts") {
                            let text = curr_date.getDate() + " tender_breasts";
                            let color = "rgba(162, 39, 219, 1.0)";
                            let background_color = "rgba(162, 39, 219, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "clearer_slippery_mucus") {
                            let text = curr_date.getDate() + " clearer slippery mucus";
                            let color = "rgba(97, 250, 179, 1.0)";
                            let background_color = "rgba(97, 250, 179, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "sticky_or_thicker_mucus") {
                            let text = curr_date.getDate() + " sticky or thicker mucus";
                            let color = "rgba(62, 191, 214, 1.0)";
                            let background_color = "rgba(62, 191, 214, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "cramps") {
                            let text = curr_date.getDate() + " cramps";
                            let color = "rgba(162, 39, 219, 1.0)";
                            let background_color = "rgba(162, 39, 219, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "positive_ovulation_test" || type == "faintly_positive_ovulation_test") {
                            let text = curr_date.getDate() + (type == "positive_ovulation_test" ? " positive ovulation test" : " faint ovulation test");
                            let color = type == "positive_ovulation_test" ? "rgba(219, 33, 117, 1.0)" : "rgba(204, 65, 128, 1.0)";
                            let background_color = type == "positive_ovulation_test" ? "rgba(219, 33, 117, 0.3)" : "rgba(204, 65, 128, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "negative_ovulation_test") {
                            let text = curr_date.getDate() + " negative ovulation test";
                            let color = "rgba(110, 57, 0, 1.0)";
                            let background_color = "rgba(110, 57, 0, 0.3)";
                            draw_flag(ctx, text, x, color, background_color, false);
                        }

                        if (type == "sick" || type == "stress") {
                            ctx.fillStyle = `rgba(147, 181, 72, 0.1)`;
                            ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);
                        }


                    }

                }

                // draw predications for this day
                if (predictions.has(date_str)) {
                    let prediction = predictions.get(date_str);
                    if (prediction == "ovulation_start") {
                        let text = curr_date.getDate() + " chance for pregnancy";
                        let color = "rgba(97, 250, 179, 1.0)";
                        let background_color = "rgba(97, 250, 179, 0.3)";

                        // background
                        ctx.fillStyle = background_color;
                        ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);

                        // flag
                        draw_flag(ctx, text, x, color, background_color, true);

                        ctx.beginPath();
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = color;

                        // up down line
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        // top bottom lines
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x + step_x, Y_MARGIN);
                        ctx.stroke();
                        ctx.moveTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        ctx.setLineDash([]);


                    }
                    else if (prediction == "ovulation") {
                        let color = "rgba(97, 250, 179, 1.0)";
                        let background_color = "rgba(97, 250, 179, 0.3)";

                        // background
                        ctx.fillStyle = background_color;
                        ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);

                        ctx.beginPath();
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = color;

                        // top bottom lines
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x + step_x, Y_MARGIN);
                        ctx.stroke();
                        ctx.moveTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        ctx.setLineDash([]);

                    }
                    else if (prediction == "ovulation_end" || prediction == "conception_date") {
                        let text = curr_date.getDate() + " ovulation";
                        let color = "rgba(97, 250, 179, 1.0)";
                        let background_color = "rgba(97, 250, 179, 0.3)";

                        // background
                        ctx.fillStyle = background_color;
                        ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);

                        // flag
                        draw_flag(ctx, text, x + step_x, color, background_color, true);

                        ctx.beginPath();
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = color;

                        // up down line
                        ctx.moveTo(x + step_x, Y_MARGIN);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        // top bottom lines
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x + step_x, Y_MARGIN);
                        ctx.stroke();
                        ctx.moveTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        ctx.setLineDash([]);

                    }
                    else if (prediction == "period_start") {
                        let text = curr_date.getDate() + " period start";
                        let color = "rgba(224, 133, 215, 0.5)";
                        let background_color = "rgba(224, 133, 215, 0.2)";

                        // background
                        ctx.fillStyle = background_color;
                        ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);

                        // flag
                        draw_flag(ctx, text, x, color, background_color, true);

                        ctx.beginPath();
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = color;

                        // up down line
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        // top bottom lines
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x + step_x, Y_MARGIN);
                        ctx.stroke();
                        ctx.moveTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        ctx.setLineDash([]);

                    }
                    else if (prediction == "period") {
                        let color = "rgba(224, 133, 215,0.5)";
                        let background_color = "rgba(224, 133, 215,0.2)";

                        // background
                        ctx.fillStyle = background_color;
                        ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);

                        ctx.beginPath();
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = color;

                        // top bottom lines
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x + step_x, Y_MARGIN);
                        ctx.stroke();
                        ctx.moveTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        ctx.setLineDash([]);

                    }
                    else if (prediction == "period_end") {
                        let text = curr_date.getDate() + " period end";
                        let color = "rgba(224, 133, 215, 0.5)";
                        let background_color = "rgba(224, 133, 215,0.2)";

                        // background
                        ctx.fillStyle = background_color;
                        ctx.fillRect(x, Y_MARGIN, step_x, graph_canvas.height - Y_MARGIN - Y_MARGIN_TOP);

                        // flag
                        draw_flag(ctx, text, x + step_x, color, background_color, true);

                        ctx.beginPath();
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = color;

                        // up down line
                        ctx.moveTo(x + step_x, Y_MARGIN);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        // top bottom lines
                        ctx.moveTo(x, Y_MARGIN);
                        ctx.lineTo(x + step_x, Y_MARGIN);
                        ctx.stroke();
                        ctx.moveTo(x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.lineTo(x + step_x, graph_canvas.height - Y_MARGIN_TOP);
                        ctx.stroke();

                        ctx.setLineDash([]);

                    }
                    // baby size
                    else {
                        draw_flag(ctx, prediction, x, "rgba(255, 165, 0, 1.0)", "rgba(255, 165, 0, 0.3)", false);
                    }
                }


                i++;
                curr_date.setDate(curr_date.getDate() + 1);
            }


            // draw temperature trend line
            if (temperatures.length > 0) {
                let last_average = null;
                const sigma = 200000000;
                for (let x = 0; x < graph_canvas.width; x++) {

                    // get closest date
                    let days = (x / step_x);
                    let ms_over = days * 24 * 60 * 60 * 1000;
                    let closest_date = new Date(start_date.getTime() + ms_over);

                    if (closest_date > temperatures[0][0] && closest_date < temperatures[temperatures.length - 1][0]) {
                        let average = 0;
                        let total_weights = 0;
                        for (let i = 0; i < temperatures.length; i++) {
                            let diff = temperatures[i][0] - closest_date;
                            let weight = Math.exp(- (diff * diff) / (2 * sigma * sigma));
                            average += temperatures[i][1] * weight;
                            total_weights += weight;
                        }
                        average /= total_weights;

                        if (last_average && average) {
                            let last_y = graph_canvas.height - BB_MARGIN - step_y * (last_average - min_temp);
                            let y = graph_canvas.height - BB_MARGIN - step_y * (average - min_temp);
                            ctx.beginPath();
                            ctx.moveTo(x - 1, last_y);
                            ctx.lineTo(x, y);
                            ctx.strokeStyle = 'rgb(200, 200, 200)';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }

                        last_average = average;
                    }
                }
            }

        }

        // dragging/scrolling
        let startX = 0;
        let startY = 0;
        let isDragging = false;

        function drag_start(e) {
            if (e.touches) {
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            }
            else {
                startX = e.clientX;
                startY = e.clientY;
            }
            isDragging = true;

        }

        function drag_move(e) {
            if (isDragging) {
                let dx;
                let dy;
                if (e.touches) {
                    const touch = e.touches[0];
                    dx = touch.clientX - startX;
                    dy = touch.clientY - startY;
                }
                else {
                    dx = e.clientX - startX;
                    dy = e.clientY - startY;
                }


                // If moved far enough, treat as slide/drag
                const threshold = 2; // px
                if (Math.abs(dx) > GRAPH_DAY_WIDTH_PIXELS) {
                    isDragging = true;
                    // console.log("sliding", dx, dy);
                    START_DATE = get_date_plus_days(START_DATE, -dx / GRAPH_DAY_WIDTH_PIXELS)
                    draw_graph(START_DATE, bb_temperatures, events);
                    if (e.touches) {
                        const touch = e.touches[0];
                        startX = touch.clientX;
                    }
                    else {
                        startX = e.clientX;
                    }


                }

            }
        }

        function drag_end(e) {
            isDragging = false;
        }
        
        graph_canvas.addEventListener("touchstart", drag_start);
        graph_canvas.addEventListener("touchmove", drag_move);
        graph_canvas.addEventListener("touchend", drag_end);
        graph_canvas.addEventListener("mousedown", drag_start);
        graph_canvas.addEventListener("mousemove", drag_move);
        graph_canvas.addEventListener("mouseup", drag_end);


        // startup
        events = local_storage_get_map("events");
        if (!events || bb_temperatures.length == 0) events = new Map();
        bb_temperatures = local_storage_get_map("bb_temperatures");
        if (!bb_temperatures || bb_temperatures.length == 0) bb_temperatures = new Map();
        make_predictions(events, bb_temperatures);
        draw_graph(START_DATE, bb_temperatures, events);

    </script>


    <!-- downalod upload -->
    <script>


        function download_data() {

            let csv_content = [];

            for (let entry of events.entries()) {
                let date = entry[0];
                let events_on_date = entry[1];

                for (let i = events_on_date.length - 1; i >= 0; i--) {
                    let event = events_on_date[i];
                    csv_content.push([date, event].join(","));
                }
            }

            for (let entry of bb_temperatures.entries()) {
                let date = entry[0];
                let temp = entry[1];
                csv_content.push([date, "bb_temperature", temp].join(","));
            }


            let csv_string = csv_content.join("\n");
            

            // Use data URL instead of blob URL for better mobile support
            let data_uri = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv_string);
            
            let a = document.createElement('a');
            a.href = data_uri;
            a.download = 'period_tracker_data.csv';
            a.click();
        }


        function upload_data() {
            let input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = e => {
                let file = e.target.files[0];
                let reader = new FileReader();
                reader.onload = event => {

                    bb_temperatures.clear();
                    events.clear();

                    let text = event.target.result;
                    let lines = text.split('\n');
                    for (let line of lines) {
                        let parts = line.split(',');
                        if (parts.length >= 2) {
                            let date = parts[0];
                            let event = parts[1];
                            if (event == "bb_temperature" && parts.length == 3) {
                                let temp = parseFloat(parts[2]);
                                bb_temperatures.set(date, temp);
                            }
                            else {
                                add_to_list_map(events, date, event);
                            }
                        }
                    }
                    local_storage_save("events", events);
                    local_storage_save("bb_temperatures", bb_temperatures);
                    make_predictions(events, bb_temperatures);
                    draw_graph(START_DATE, bb_temperatures, events, predictions);
                };
                reader.readAsText(file);
            };
            input.click();
        }

    </script>









</body>

</html>